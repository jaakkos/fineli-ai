/**
 * Local Fineli food index — fully offline food search using Fineli Open Data.
 *
 * Built from Fineli Open Data (CC-BY 4.0, Finnish Institute for Health and Welfare).
 * The index.json is generated by scripts/build-fineli-index.ts (fetches data from
 * Fineli, no CSVs in git). Search uses FlexSearch for fast, flexible matching.
 *
 * This module completely replaces the Fineli REST API for search, providing:
 * 1. searchFoods()     — returns FineliFood[] (drop-in replacement for API search)
 * 2. getFoodDetails()  — returns full nutrient data for a food by ID
 * 3. localSearch()    — scored search results with match metadata
 * 4. getRecipe()       — recipe decomposition for composite foods
 * 5. getPortionSizes() — real Fineli portion sizes (small/medium/large)
 * 6. getFoodMeta()     — food type, ingredient class, food use class
 */

import { readFileSync } from 'fs';
import { join } from 'path';
import { Index } from 'flexsearch';
import type { FineliFood, FineliUnit } from '@/types';
import { normalizeQuery, FOOD_ALIASES } from './search';

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export interface LocalFoodEntry {
  id: number;
  name: string;
  type: 'FOOD' | 'DISH';
  process: string;
  igclass: string;
  fuclass: string;
}

export interface RecipeIngredient {
  id: number;
  name: string;
  grams: number;
}

export interface PortionSize {
  unit: string;
  grams: number;
}

export interface LocalSearchResult {
  food: LocalFoodEntry;
  score: number;
  matchType: 'exact' | 'primary' | 'contains' | 'word';
}

// ---------------------------------------------------------------------------
// Index loading (lazy singleton)
// ---------------------------------------------------------------------------

interface FineliIndex {
  foods: LocalFoodEntry[];
  recipes: Record<number, { ingredients: RecipeIngredient[] }>;
  portions: Record<number, PortionSize[]>;
  nutrients: Record<number, Record<string, number>>;
  unitLabels: Record<string, string>;
  /** @deprecated No longer in index.json; search uses FlexSearch */
  nameIndex?: Record<string, number[]>;
}

let _index: FineliIndex | null = null;

function getIndex(): FineliIndex {
  if (_index) return _index;

  try {
    const indexPath = join(process.cwd(), 'data', 'fineli', 'index.json');
    const raw = readFileSync(indexPath, 'utf-8');
    _index = JSON.parse(raw) as FineliIndex;
    return _index;
  } catch {
    console.warn('[Fineli Local Index] index.json not found — local search disabled');
    _index = {
      foods: [], recipes: {}, portions: {},
      nutrients: {}, unitLabels: {},
    };
    return _index;
  }
}

let _foodById: Map<number, LocalFoodEntry> | null = null;

function getFoodById(): Map<number, LocalFoodEntry> {
  if (_foodById) return _foodById;
  const index = getIndex();
  _foodById = new Map(index.foods.map((f) => [f.id, f]));
  return _foodById;
}

/**
 * FlexSearch indexes by category (FOOD vs DISH).
 * Best practice: use numeric IDs and split content by category into separate
 * indexes for better performance and memory — see
 * https://emersonbottero.github.io/flexsearch/api/best-practice.html
 */
type FoodCategory = 'FOOD' | 'DISH';
let _searchIndexes: Record<FoodCategory, Index> | null = null;

function getSearchIndexes(): Record<FoodCategory, Index> | null {
  if (_searchIndexes) return _searchIndexes;
  const index = getIndex();
  if (index.foods.length === 0) return null;

  const opts = { tokenize: 'forward' as const, resolution: 9 };
  const byCategory: Record<FoodCategory, Index> = {
    FOOD: new Index(opts),
    DISH: new Index(opts),
  };
  for (const food of index.foods) {
    const text = food.name.toLowerCase();
    byCategory[food.type].add(food.id, text);
  }
  _searchIndexes = byCategory;
  return _searchIndexes;
}

// ---------------------------------------------------------------------------
// Convert local data → FineliFood (same shape as the old API response)
// ---------------------------------------------------------------------------

const KJ_TO_KCAL = 0.239006;

function toFineliFood(entry: LocalFoodEntry): FineliFood {
  const index = getIndex();
  const rawNutrients = index.nutrients[entry.id] ?? {};

  const nutrients: Record<string, number> = { ...rawNutrients };

  const energyKj = rawNutrients['ENERC'] ?? 0;
  const energyKcal = Math.round(energyKj * KJ_TO_KCAL);

  const portions = index.portions[entry.id] ?? [];
  const units: FineliUnit[] = portions.map((p) => ({
    code: p.unit,
    labelFi: index.unitLabels[p.unit] ?? p.unit,
    labelEn: index.unitLabels[p.unit] ?? p.unit,
    massGrams: p.grams,
  }));

  return {
    id: entry.id,
    nameFi: entry.name,
    nameEn: null,
    nameSv: null,
    type: entry.type,
    preparationMethods: entry.process ? [entry.process] : [],
    units,
    nutrients,
    energyKj,
    energyKcal,
    fat: rawNutrients['FAT'] ?? 0,
    protein: rawNutrients['PROT'] ?? 0,
    carbohydrate: rawNutrients['CHOAVL'] ?? 0,
  };
}

// ---------------------------------------------------------------------------
// 1. searchFoods() — drop-in replacement for FineliClient.searchFoods()
// ---------------------------------------------------------------------------

/**
 * Search the local Fineli index. Returns FineliFood[] — same shape as the API.
 * Applies FOOD_ALIASES and normalizeQuery for consistency with the old client.
 */
export function searchFoods(query: string, _lang?: string): FineliFood[] {
  const normalized = normalizeQuery(query);
  const alias = FOOD_ALIASES[normalized];

  // Try alias first, fall back to original query if alias yields no results
  if (alias && alias !== normalized) {
    const aliasResults = localSearch(alias, 20);
    if (aliasResults.length > 0) {
      return aliasResults.map((r) => toFineliFood(r.food));
    }
  }

  const results = localSearch(normalized, 20);
  return results.map((r) => toFineliFood(r.food));
}

/**
 * Get full food details by Fineli ID (replaces FineliClient.getFoodDetails).
 */
export function getFoodDetails(foodId: number): FineliFood | null {
  const entry = getFoodById().get(foodId);
  if (!entry) return null;
  return toFineliFood(entry);
}

// ---------------------------------------------------------------------------
// 2. localSearch() — scored search with match metadata
// ---------------------------------------------------------------------------

/**
 * Compute score and matchType for a food given the query (already normalized).
 */
function scoreMatch(food: LocalFoodEntry, q: string): { score: number; matchType: LocalSearchResult['matchType'] } {
  const nameLower = food.name.toLowerCase();
  const nameNorm = nameLower.replace(/,/g, ' ').replace(/\s+/g, ' ').trim();
  const primary = nameLower.split(',')[0].trim();
  const qWords = q.split(/\s+/);
  const qCompound = qWords.length >= 2 ? qWords.join('') : null;

  // Exact full-string matches
  if (nameLower === q || nameNorm === q) return { score: 100, matchType: 'exact' };
  if (primary === q) return { score: 90, matchType: 'primary' };

  // Compound word match: "kana curry" → matches "kanacurry" in name
  if (qCompound && (nameLower.includes(qCompound) || primary.includes(qCompound))) {
    const inPrimary = primary.includes(qCompound);
    return { score: inPrimary ? 85 : 65, matchType: inPrimary ? 'primary' : 'contains' };
  }

  // Multi-word queries: score by how many words match and where
  if (qWords.length > 1) {
    const matchCount = qWords.filter((w) => nameLower.includes(w)).length;

    if (matchCount === qWords.length) {
      // All query words found — strong match
      let score = 70;
      // Bonus if primary name starts with a query word (e.g. "ruisleipä" in "ruisleipä, reissumies...")
      if (qWords.some((w) => primary.startsWith(w))) score += 5;
      // Prefer shorter, more specific names
      if (nameLower.length < 50) score += 3;
      if (nameLower.length < 35) score += 2;
      return { score, matchType: 'contains' };
    }
    if (matchCount >= Math.ceil(qWords.length * 0.6)) {
      // Partial word match — decent but not all words found
      return { score: 15 + matchCount * 8, matchType: 'word' };
    }
  }

  // Single-word partial matches
  if (primary.startsWith(q) || nameLower.startsWith(q)) return { score: 80, matchType: 'primary' };
  if (primary.includes(q)) return { score: 60, matchType: 'contains' };
  if (nameLower.includes(q)) return { score: 40, matchType: 'contains' };

  return { score: 5, matchType: 'word' };
}

/**
 * Normalize a search query: lowercase, strip commas (Fineli uses them as
 * separators, not meaningful punctuation), collapse whitespace.
 */
function normalizeSearchQuery(raw: string): string {
  return raw.toLowerCase().replace(/,/g, ' ').replace(/\s+/g, ' ').trim();
}

/**
 * Search the local Fineli index by Finnish food name using FlexSearch.
 * Returns scored results sorted by relevance.
 */
export function localSearch(query: string, limit: number = 10): LocalSearchResult[] {
  const index = getIndex();
  if (index.foods.length === 0) return [];

  const q = normalizeSearchQuery(query);
  if (!q) return [];

  const indexes = getSearchIndexes();
  const byId = getFoodById();

  const results: LocalSearchResult[] = [];
  const seen = new Set<number>();

  // Build search variants: original query + compound form for multi-word
  // Finnish often joins words: "kana curry" → "kanacurry"
  const qWords = q.split(/\s+/);
  const searchTerms = [q];
  if (qWords.length >= 2) {
    searchTerms.push(qWords.join(''));
  }

  if (indexes) {
    const candidateLimit = Math.max(limit * 3, 50);
    const perCategory = Math.ceil(candidateLimit / 2);
    for (const term of searchTerms) {
      const foodIds = indexes.FOOD.search(term, { limit: perCategory }) as number[];
      const dishIds = indexes.DISH.search(term, { limit: perCategory }) as number[];
      const ids = [...foodIds, ...dishIds];
      for (const id of ids) {
        if (seen.has(id)) continue;
        const food = byId.get(id);
        if (!food) continue;
        seen.add(id);
        const { score, matchType } = scoreMatch(food, q);
        results.push({ food, score, matchType });
      }
    }
  }

  if (results.length < limit) {
    for (const food of index.foods) {
      if (seen.has(food.id)) continue;
      const nameLower = food.name.toLowerCase();
      const primary = nameLower.split(',')[0].trim();
      // Check original query and compound form against name
      const matchesDirect = primary.includes(q) || nameLower.includes(q);
      const matchesCompound = searchTerms.length > 1 &&
        (primary.includes(searchTerms[1]) || nameLower.includes(searchTerms[1]));
      if (matchesDirect || matchesCompound) {
        seen.add(food.id);
        const { score, matchType } = scoreMatch(food, q);
        results.push({ food, score, matchType });
        continue;
      }
      if (qWords.length > 1) {
        const matchCount = qWords.filter((w) => nameLower.includes(w)).length;
        if (matchCount >= Math.ceil(qWords.length * 0.6)) {
          seen.add(food.id);
          const { score, matchType } = scoreMatch(food, q);
          results.push({ food, score, matchType });
        }
      }
    }
  }

  results.sort((a, b) => {
    if (b.score !== a.score) return b.score - a.score;
    return a.food.name.length - b.food.name.length;
  });

  return results.slice(0, limit);
}

// ---------------------------------------------------------------------------
// 3. Recipe lookup — composite food decomposition
// ---------------------------------------------------------------------------

/**
 * Get the Fineli recipe for a food (if it's a composite/prepared dish).
 * Returns ingredient list with names and gram amounts.
 */
export function getRecipe(foodId: number): RecipeIngredient[] | null {
  const index = getIndex();
  const recipe = index.recipes[foodId];
  if (!recipe || recipe.ingredients.length === 0) return null;
  return recipe.ingredients;
}

/**
 * Check if a food name matches a known whole dish in Fineli.
 * If so, returns the best matching food entry.
 */
export function findWholeDish(query: string): LocalFoodEntry | null {
  const results = localSearch(query, 5);
  for (const r of results) {
    if (r.food.type === 'DISH' && r.score >= 40) {
      return r.food;
    }
  }
  for (const r of results) {
    if (r.score >= 70) {
      return r.food;
    }
  }
  return null;
}

// ---------------------------------------------------------------------------
// 4. Portion sizes — real Fineli data
// ---------------------------------------------------------------------------

/**
 * Get Fineli portion sizes for a food (small/medium/large, dl, tl, rkl, etc.)
 */
export function getPortionSizes(foodId: number): PortionSize[] | null {
  const index = getIndex();
  const portions = index.portions[foodId];
  if (!portions || portions.length === 0) return null;
  return portions;
}

/**
 * Get the "medium portion" (PORTM) in grams for a food, or null.
 */
export function getMediumPortion(foodId: number): number | null {
  const portions = getPortionSizes(foodId);
  if (!portions) return null;

  const medium = portions.find((p) => p.unit === 'PORTM') ??
    portions.find((p) => p.unit === 'KPL_M');
  return medium?.grams ?? null;
}

// ---------------------------------------------------------------------------
// 5. Food metadata
// ---------------------------------------------------------------------------

export function getFoodMeta(foodId: number): LocalFoodEntry | null {
  return getFoodById().get(foodId) ?? null;
}

export function isDish(foodId: number): boolean {
  const meta = getFoodMeta(foodId);
  return meta?.type === 'DISH';
}
